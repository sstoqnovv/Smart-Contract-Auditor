1. **ERC20 transfer and transferFrom**: Should return a boolean. Several tokens do not return a boolean on these functions. As a result, their calls in the contract might fail. The best security pitfall is to check if the boolean is return.
2. **ERC20 name, decimals, and symbol functions**: Are present if used. These functions are optional in the ERC20 standard and might not be present.
3. **ERC20 decimals returns a uint8**: Several tokens incorrectly return a uint256. If this is the case, ensure the value returned is below 255.
4. **ERC20** _**approve**_ **race-condition**: The ERC20 standard has a known ERC20 race condition that must be mitigated to prevent attackers from stealing tokens. The best practice here is to not use _approve()__, but instead use the _increaseAllowance() and decreaseAllowance()__.

5. **ERC777 hooks**: ERC777 tokens have the concept of a hook function that is called before any calls to send, transfer, operatorSend, minting and burning. While these hooks enable a lot of interesting use cases, care should be taken to make sure they do not make external calls because that can lead to reentrancies. (See [here](https://github.com/crytic/building-secure-contracts/blob/master/development-guidelines/token_integration.md#erc-conformity))

6. **Token only has one address**: Tokens with multiple entry points for balance updates can break internal bookkeeping based on the address .
7. **token is not upgradeable**: Upgradeable contracts might change their rules over time.
8. **Token is not pausable**: Malicious or compromised owners can trap contracts relying on pausable tokens.

9. **ERC1400 forced transfers**: Trusted actors have the ability to transfer funds however they choose.
10. **ERC1644 forced transfers**: Controller has the ability to steal funds.
11. **ERC621 control of totalSupply**: totalSupply can be changed by trusted actors.
12. **ERC884 cancel and reissue**: Token implementers have the ability to cancel an address and move its tokens to a new address.
13. **ERC884 whitelisting**: Tokens can only be sent to whitelisted addresses
	 - Whitelisted addresses refer to a specific list of addresses that have been granted certain privileges or permissions within a system. In the context of ERC884 whitelisting, it means that only the addresses listed in the whitelist are allowed to receive tokens. ERC884 is an Ethereum token standard that allows for the implementation of whitelisting functionality within a smart contract. It enables token issuers or contract administrators to define a list of approved addresses to which tokens can be sent.

14. **Guarded launch via asset limits**: Limiting the total asset value managed by a system initially upon launch and gradually increasing it over time may reduce impact due to initial vulnerabilities or exploits. (See [here](https://medium.com/electric-capital/derisking-defi-guarded-launches-2600ce730e0a#:~:text=Guarded%20Launches:%20Protecting%20Users%20with%20Limits&text=A%20new%20contract%20is%20deployed,product%20in%20a%20limited%20scope.))
    
15. **Guarded launch via asset types:** Limiting types of assets that can be used in the protocol initially upon launch and gradually expanding to other assets over time may reduce impact due to initial vulnerabilities or exploits. (See [here](https://medium.com/electric-capital/derisking-defi-guarded-launches-2600ce730e0a#:~:text=Guarded%20Launches:%20Protecting%20Users%20with%20Limits&text=A%20new%20contract%20is%20deployed,product%20in%20a%20limited%20scope.))
    
16. **Guarded launch via user limits:** Limiting the total number of users that can interact with a system initially upon launch and gradually increasing it over time may reduce impact due to initial vulnerabilities or exploits. Initial users may also be whitelisted to limit to trusted actors before opening the system to everyone. Launch -> Few/Trusted Users, Over Time -> Increase users. (See [here](https://medium.com/electric-capital/derisking-defi-guarded-launches-2600ce730e0a#:~:text=Guarded%20Launches:%20Protecting%20Users%20with%20Limits&text=A%20new%20contract%20is%20deployed,product%20in%20a%20limited%20scope.))
    
17. **Guarded launch via usage limits**: Enforcing transaction size limits, daily volume limits, per-account limits, or rate-limiting transactions may reduce impact due to initial vulnerabilities or exploits. (See [here](https://medium.com/electric-capital/derisking-defi-guarded-launches-2600ce730e0a#:~:text=Guarded%20Launches:%20Protecting%20Users%20with%20Limits&text=A%20new%20contract%20is%20deployed,product%20in%20a%20limited%20scope.))
    
18. **Guarded launch via composability limits:** Restricting the composability of the system to interface only with whitelisted trusted contracts before expanding to arbitrary external contracts may reduce impact due to initial vulnerabilities or exploits. (See [here](https://medium.com/electric-capital/derisking-defi-guarded-launches-2600ce730e0a#:~:text=Guarded%20Launches:%20Protecting%20Users%20with%20Limits&text=A%20new%20contract%20is%20deployed,product%20in%20a%20limited%20scope.))
    
19. **Guarded launch via escrows**: Escrowing high value transactions/operations with time locks and a governance capability to nullify or revert transactions may reduce impact due to initial vulnerabilities or exploits. (See [here](https://medium.com/electric-capital/derisking-defi-guarded-launches-2600ce730e0a#:~:text=Guarded%20Launches:%20Protecting%20Users%20with%20Limits&text=A%20new%20contract%20is%20deployed,product%20in%20a%20limited%20scope.))
    
20. **Guarded launch via circuit breakers**: Implementing capabilities to pause/unpause a system in extreme scenarios may reduce impact due to initial vulnerabilities or exploits. Emergency -> Pause, Recover -> Unpause.(See [here](https://medium.com/electric-capital/derisking-defi-guarded-launches-2600ce730e0a#:~:text=Guarded%20Launches:%20Protecting%20Users%20with%20Limits&text=A%20new%20contract%20is%20deployed,product%20in%20a%20limited%20scope.))
    
21. **Guarded launch via emergency shutdown:** Implement capabilities that allow governance to shutdown new activity in the system and allow users to reclaim assets may reduce impact due to initial vulnerabilities or exploits. (See [here](https://medium.com/electric-capital/derisking-defi-guarded-launches-2600ce730e0a#:~:text=Guarded%20Launches:%20Protecting%20Users%20with%20Limits&text=A%20new%20contract%20is%20deployed,product%20in%20a%20limited%20scope.))

22. **System specification**: Ensure that the specification of the entire system is considered, written and evaluated to the greatest detail possible. Specification describes how (and why) the different components of the system behave to achieve the design requirements. Without specification, a system implementation cannot be evaluated against the requirements for correctness.
23. **System documentation**: Ensure that roles, functionalities and interactions of the entire system are well documented to the greatest detail possible. Documentation describes what (and how) the implementation of different components of the system does to achieve the specification goals. Without documentation, a system implementation cannot be evaluated against the specification for correctness and one will have to rely on analyzing the implementation itself.

24. **Function parameters**: Ensure input validation for all function parameters especially if the visibility is external/public where (untrusted) users can control values. This is especially required for address parameters where maliciously/accidentally used incorrect/zero addresses can cause vulnerabilities or unexpected behavior.
25. **Function arguments**: Ensure that the arguments to function calls at the caller sites are the correct ones and in the right order as expected by the function definition.
26. **Function visibility**: Ensure that the strictest visibility is used for the required functionality. An accidental external/public visibility will allow (untrusted) users to invoke functionality that is supposed to be restricted internally.
27. **Function modifiers**: Ensure that the right set of function modifiers are used (in the correct order) for the specific functions so that the expected access control or validation is correctly enforced.
28. **Function return values**: Ensure that the appropriate return value(s) are returned from functions and checked without ignoring at function call sites, so that error conditions are caught and handled appropriately.
29. **Function invocation timeliness**: Externally accessible functions (_external_/_public_ visibility) may be called at any time (or never). It is not safe to assume they will only be called at specific system phases (e.g. after initialization, when unpaused, during liquidation) that is meaningful to the system design. The reason for this can be accidental or malicious. Function implementation should be robust enough to track system state transitions, determine meaningful states for invocations and withstand arbitrary calls. For e.g., initialization functions (used with upgradeable contracts that cannot use constructors) are meant to be called atomically along with contract deployment to prevent anyone else from initializing with arbitrary values.
30. **Function invocation repetitiveness**: Externally accessible functions (_external_/_public_ visibility) may be called any number of times. It is not safe to assume they will only be called only once or a specific number of times that is meaningful to the system design. Function implementation should be robust enough to track, prevent, ignore or account for arbitrarily repetitive invocations. For e.g., initialization functions (used with upgradeable contracts that cannot use constructors) are meant to be called only once.
31. **Function invocation order:**  Externally accessible functions (_external_/_public_ visibility) may be called in any order (with respect to other defined functions). It is not safe to assume they will only be called in the specific order that makes sense to the system design or is implicitly assumed in the code. For e.g., initialization functions (used with upgradeable contracts that cannot use constructors) are meant to be called before other system functions can be called.
32. **Function invocation arguments**: Externally accessible functions (_external_/_public_ visibility) may be called with any possible arguments. Without complete and proper validation (e.g. zero address checks, bound checks, threshold checks etc.), they cannot be assumed to comply with any assumptions made about them in the code.

33. **Conditionals**: Ensure that in conditional expressions (e.g. if statements), the correct variables are being checked and the correct operators, if any, are being used to combine them. For e.g. using || instead of && is a common error.

34. **Access control specification**: Ensure that the various system actors, their access control privileges and trust assumptions are accurately specified in great detail so that they are correctly implemented and enforced across different contracts, functions and system transitions/flows.
35. **Access control implementation**: Ensure that the specified access control is implemented uniformly across all the subjects (actors) seeking access and objects (variables, functions) being accessed so that there are no paths/flows where the access control is missing or may be side-stepped.
36. **Missing modifiers**: Access control is typically enforced on functions using modifiers that check if specific addresses/roles are calling these functions. Ensure that such modifiers are present on all relevant functions which require that specific access control.
37. **Incorrectly implemented modifiers**: Access control is typically enforced on functions using modifiers that check if specific addresses/roles are calling these functions. A system can have multiple roles with different privileges. Ensure that modifiers are implementing the expected checks on the correct roles/addresses with the right composition e.g. incorrect use of || instead of && is a common vulnerability while composing access checks.
38. **Incorrectly used modifiers**: Access control is typically enforced on functions using modifiers that check if specific addresses/roles are calling these functions. A system can have multiple roles with different privileges. Ensure that correct modifiers are used on functions requiring specific access control enforced by that modifier.
39. **Access control changes**: Ensure that changes to access control (e.g. change of ownership to new addresses) are handled with extra security so that such transitions happen smoothly without contracts getting locked out or compromised due to use of incorrect credentials.
40. **Comments**: Ensure that the code is well commented both with NatSpec and inline comments for better readability and maintainability. The comments should accurately reflect what the corresponding code does.
	 -  For Solidity you may choose `///` for single or multi-line comments, or `/**` and ending with `*/`.
	 - Tags:
			  - |`@title`|A title that should describe the contract/interface|contract, library, interface|
			  - |`@author`|The name of the author|contract, library, interface|
			  - |`@notice`|Explain to an end user what this does|contract, library, interface, function, public state variable, event|
			  - |`@dev`|Explain to a developer any extra details|contract, library, interface, function, state variable, event 
			  - |`@param`|Documents a parameter just like in Doxygen (must be followed by parameter name)|function, event 
			  - |`@return`|Documents the return variables of a contract’s function|function, public state variable 
			  - |`@inheritdoc`|Copies all missing tags from the base function (must be followed by the contract name)|function, public state variable 
			  - |`@custom:...`|Custom tag, semantics is application-defined|everywhere|

41. **Tests**: Tests indicate that the system implementation has been validated against the specification.

42. **Unused constructs**: Any unused imports, inherited contracts, functions, parameters, variables, modifiers, events or return values should be removed (or used appropriately) after careful evaluation.

43. **ETH Handling**: Contracts that accept/manage/transfer ETH should ensure that functions handling ETH are using _msg.value_ appropriately, logic that depends on ETH value accounts for less/more ETH sent, logic that depends on contract ETH balance accounts for the different direct/indirect (e.g. _coinbase_ transaction, _selfdestruct_ recipient) ways of receiving ETH and transfers are reentrancy safe. Functions handling ETH should be checked extra carefully for access control, input validation and error handling.
44. **Token Handling**: Contracts that accept/manage/transfer ERC tokens should ensure that functions handling tokens account for different types of ERC tokens (e.g. ERC20 vs ERC777), deflationary/inflationary tokens, rebasing tokens and trusted/external tokens. Functions handling tokens should be checked extra carefully for access control, input validation and error handling.

45. **Trusted actors**: Ideally there should be no trusted actors while interacting with smart contracts. However, in guarded launch scenarios, the goal is to start with trusted actors and then progressively decentralise towards automated governance by community/DAO.
46. **Privileged roles and EOAs**: Trusted actors who have privileged roles with capabilities to deploy contracts, change critical parameters, pause/unpause system, trigger emergency shutdown, withdraw/transfer/drain funds and allow/deny other actors should be addresses controlled by multiple, independent, mutually distrusting entities. They should not be controlled by private keys of EOAs but with Multisigs with a high threshold (e.g. 5-of-7, 9-of-11) and eventually by a DAO of token holders. EOA has a single point of failure.
47. **Two-step change of privileged roles**: When privileged roles are being changed, it is recommended to follow a two-step approach: 1) The current privileged role proposes a new address for the change 2) The newly proposed address then claims the privileged role in a separate transaction. This two-step change allows accidental proposals to be corrected instead of leaving the system operationally with no/malicious privileged role. For e.g., in a single-step change, if the current admin accidentally changes the new admin to a zero-address or an incorrect address (where the private keys are not available), the system is left without an operational admin and will have to be redeployed.
48. When critical parameters of systems need to be changed, it is required to broadcast the change via event emission and recommended to enforce the changes after a time-delay.

49. **Gas issues**: Incorrect assumptions about gas requirements especially for loops or external calls will lead to out-of-gas exceptions which may lead to security issues such as failed transfers or locked funds.
50. **DoS** - Users -> Access, Affect Shared State -> DoS. Effects: Lock Funds, Lose Profit, Tx inclusion, Griefing. To prevent from it: Regognize and Minimize DoS attributes.

51. **Principle of Least Privilege**: “Every program and every user of the system should operate using the least set of privileges necessary to complete the job” — Ensure that various system actors have the least amount of privilege granted as required by their roles to execute their specified tasks.
52. **Principle of Separation of Privilege**: “Where feasible, a protection mechanism that requires two keys to unlock it is more robust and flexible than one that allows access to the presenter of only a single key” — Ensure that critical privileges are separated across multiple actors so that there are no single points of failure/abuse.
53. **Principle of Least Common Mechanism**: “Minimize the amount of mechanism common to more than one user and depended on by all users” — Ensure that only the least number of security-critical modules/paths as required are shared amongst the different actors/code so that impact from any vulnerability/compromise in shared components is limited and contained to the smallest possible subset.
54. **Principle of Complete Mediation**: “Every access to every object must be checked for authority.” — Ensure that any required access control is enforced along all access paths to the object or function being protected.
55. **Principle of Economy of Mechanism**: “Keep the design as simple and small as possible” — Ensure that contracts and functions are not overly complex or large so as to reduce readability or maintainability.