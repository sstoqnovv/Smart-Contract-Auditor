Neither contracts nor “external accounts” are currently able to prevent someone from sending them Ether. Contracts can react on and reject a regular transfer, but there are ways to move Ether without creating a message call. One way is to simply “mine to” the contract address and the second way is using `selfdestruct(x)`.

If a contract receives Ether (without a function being called), either the [receive Ether](https://docs.soliditylang.org/en/latest/contracts.html#receive-ether-function) or the [fallback](https://docs.soliditylang.org/en/latest/contracts.html#fallback-function) function is executed. If it does not have a `receive` nor a `fallback` function, the Ether will be rejected (by throwing an exception).

There is a way to forward more gas to the receiving contract using `addr.call{value: x}("")`. This is essentially the same as `addr.transfer(x)`, only that it forwards all remaining gas and opens up the ability for the recipient to perform more expensive actions (and it returns a failure code instead of automatically propagating the error). This might include calling back into the sending contract or other state changes you might not have thought of. So it allows for great flexibility for honest users but also for malicious actors.

- If you want to send Ether using `address.transfer`, there are certain details to be aware of:
    
    1. If the recipient is a contract, it causes its receive or fallback function to be executed which can, in turn, call back the sending contract.
    2. Sending Ether can fail due to the call depth going above 1024. Since the caller is in total control of the call depth, they can force the transfer to fail; take this possibility into account or use `send` and make sure to always check its return value. Better yet, write your contract using a pattern where the recipient can withdraw Ether instead.
    3. Sending Ether can also fail because the execution of the recipient contract requires more than the allotted amount of gas (explicitly by using [require](https://docs.soliditylang.org/en/latest/control-structures.html#assert-and-require), [assert](https://docs.soliditylang.org/en/latest/control-structures.html#assert-and-require), [revert](https://docs.soliditylang.org/en/latest/control-structures.html#assert-and-require) or because the operation is too expensive) - it “runs out of gas” (OOG). If you use `transfer` or `send` with a return value check, this might provide a means for the recipient to block progress in the sending contract. Again, the best practice here is to use a [“withdraw” pattern instead of a “send” pattern](https://docs.soliditylang.org/en/latest/common-patterns.html#withdrawal-pattern).

External function calls can fail at any time because they exceed the maximum call stack size limit of 1024. In such situations, Solidity throws an exception. Malicious actors might be able to force the call stack to a high value before they interact with your contract. Note that, since [Tangerine Whistle](https://eips.ethereum.org/EIPS/eip-608) hardfork, the [63/64 rule](https://eips.ethereum.org/EIPS/eip-150) makes call stack depth attack impractical. Also note that the call stack and the expression stack are unrelated, even though both have a size limit of 1024 stack slots.

Note that `.send()` does **not** throw an exception if the call stack is depleted but rather returns `false` in that case. The low-level functions `.call()`, `.delegatecall()` and `.staticcall()`